<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Universe OpenAstronomy (Posts about radis)</title><link>http://openastronomy.org/Universe_OA/</link><description></description><atom:link href="http://openastronomy.org/Universe_OA/categories/radis.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sun, 14 Aug 2022 02:29:53 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Welcome to Jekyll!</title><link>http://openastronomy.org/Universe_OA/posts/2022/08/20220810_1030_sagarchotalia/</link><dc:creator>OpenAstronomy</dc:creator><description>&lt;p&gt;You’ll find this post in your &lt;code class="language-plaintext highlighter-rouge"&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class="language-plaintext highlighter-rouge"&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;Jekyll requires blog post files to be named according to the following format:&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where &lt;code class="language-plaintext highlighter-rouge"&gt;YEAR&lt;/code&gt; is a four-digit number, &lt;code class="language-plaintext highlighter-rouge"&gt;MONTH&lt;/code&gt; and &lt;code class="language-plaintext highlighter-rouge"&gt;DAY&lt;/code&gt; are both two-digit numbers, and &lt;code class="language-plaintext highlighter-rouge"&gt;MARKUP&lt;/code&gt; is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class="highlight"&gt;&lt;pre&gt;&lt;code class="language-ruby"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_hi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"Hi, &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="nb"&gt;name&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;print_hi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Tom'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href="https://jekyllrb.com/docs/home"&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href="https://talk.jekyllrb.com/"&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/08/20220810_1030_sagarchotalia/</guid><pubDate>Wed, 10 Aug 2022 09:30:40 GMT</pubDate></item><item><title>Advanced options</title><link>http://openastronomy.org/Universe_OA/posts/2022/07/20220731_0000_arunavabasu-03/</link><dc:creator>arunavabasu-03</dc:creator><description>&lt;p&gt;Impove default resolution of ploted spectrum In  wstep = “auto”  radis app gives slitly low res. for that reasons plotted  spectrum  is…&lt;/p&gt;
&lt;div style="margin-top: 50px; font-style: italic;"&gt;&lt;strong&gt;&lt;a href="https://minimal-blog.lekoarts.de/6thweek/"&gt;Keep reading&lt;/a&gt;.&lt;/strong&gt;&lt;/div&gt;&lt;br&gt; &lt;br&gt;
&lt;!-- TEASER_END --&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/07/20220731_0000_arunavabasu-03/</guid><pubDate>Sat, 30 Jul 2022 23:00:00 GMT</pubDate></item><item><title>Implementing React Hook Form</title><link>http://openastronomy.org/Universe_OA/posts/2022/07/20220724_0000_arunavabasu-03/</link><dc:creator>arunavabasu-03</dc:creator><description>&lt;p&gt;After analyzing the the benchmarks and taking with my mentors , we are decided to go with  React Hook Form  for it’s performace , low…&lt;/p&gt;
&lt;div style="margin-top: 50px; font-style: italic;"&gt;&lt;strong&gt;&lt;a href="https://minimal-blog.lekoarts.de/4th&amp;amp;5thWeek/"&gt;Keep reading&lt;/a&gt;.&lt;/strong&gt;&lt;/div&gt;&lt;br&gt; &lt;br&gt;
&lt;!-- TEASER_END --&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/07/20220724_0000_arunavabasu-03/</guid><pubDate>Sat, 23 Jul 2022 23:00:00 GMT</pubDate></item><item><title>Week 5 and Week 6</title><link>http://openastronomy.org/Universe_OA/posts/2022/07/20220723_0000_supriya1702/</link><dc:creator>Supriya1702</dc:creator><description>&lt;p&gt;Entering into the 5th week I created a PR  https://github.com/radis/radis/pull/492   to address the task to add, retrieve and store the…&lt;/p&gt;
&lt;div style="margin-top: 50px; font-style: italic;"&gt;&lt;strong&gt;&lt;a href="https://minimal-blog.lekoarts.de/week-5-and-week-6"&gt;Keep reading&lt;/a&gt;.&lt;/strong&gt;&lt;/div&gt;&lt;br&gt; &lt;br&gt;
&lt;!-- TEASER_END --&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/07/20220723_0000_supriya1702/</guid><pubDate>Fri, 22 Jul 2022 23:00:00 GMT</pubDate></item><item><title>Fifth week - Major updates on literally everything, and non-LTE benchmarking</title><link>http://openastronomy.org/Universe_OA/posts/2022/07/20220717_0000_tranhuunhathuy/</link><dc:creator>TranHuuNhatHuy</dc:creator><description>&lt;p&gt;&lt;a href="https://gsoc2022tranhuunhathuy.gatsbyjs.io/b6a43fd435ed51da926a7346d2f66de9/JSON_sample.json"&gt;JSON sample&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;1. Fitting method benchmarking&lt;/h4&gt;
&lt;p&gt;The ideal of benchmarking result is to test and assess under what conditions, such as fitting method, pipeline, refinement, etc., the fitting process can achieve a stable and robust result. Firstly, I want to test the fitting method and see which ones are the best to put into the module as the default method. As we use LMFIT.Minimizer, we have 23 fitting methods in total:&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt;: Levenberg-Marquardt (default).&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;least_squares&lt;/code&gt;: Least-Squares minimization, using Trust Region Reflective method.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;differential_evolution&lt;/code&gt;: differential evolution.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;brute&lt;/code&gt;: brute force method.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;basinhopping&lt;/code&gt;: Basin-hopping method.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;ampgo&lt;/code&gt;: Adaptive Memory Programming for Global Optimization.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;nelder&lt;/code&gt;: Nelder-Mead.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;lbfgsb&lt;/code&gt;: Limited-memory Broyden–Fletcher–Goldfarb–Shanno (L-BFGS-B).&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;powell&lt;/code&gt;: Powell’s method.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;cg&lt;/code&gt;: Conjugate-Gradient.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;newton&lt;/code&gt;: Newton-Conjugate-Gradient.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;cobyla&lt;/code&gt;: Cobyla.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;bfgs&lt;/code&gt;: Broyden–Fletcher–Goldfarb–Shanno (BFGS).&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;tnc&lt;/code&gt;: Truncated Newton.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;trust-ncg&lt;/code&gt;: Newton-Conjugate-Gradient trust-region.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;trust-exact&lt;/code&gt;: nearly exact trust-region.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;trust-krylov&lt;/code&gt;: Newton’s Generalized Lanczos Trust-Region (GLTR).&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;trust-constr&lt;/code&gt;: trust-region for constrained optimization.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;dogleg&lt;/code&gt;: Dog-leg trust-region.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;slsqp&lt;/code&gt;: Sequential Linear Squares Programming.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;emcee&lt;/code&gt;: Maximum likelihood via Monte-Carlo Markov Chain.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;shgo&lt;/code&gt;: Simplicial Homology Global Optimization.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;dual_annealing&lt;/code&gt;: Dual Annealing optimization.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this list, there are 5 methods - &lt;code class="language-text"&gt;newton&lt;/code&gt;, &lt;code class="language-text"&gt;trust-ncg&lt;/code&gt;, &lt;code class="language-text"&gt;trust_exact&lt;/code&gt;, &lt;code class="language-text"&gt;trust-krylov&lt;/code&gt; and &lt;code class="language-text"&gt;dogleg&lt;/code&gt; - that require Jacobian function to work, which adds more complexity into our fitting process and codebase, hence I remove them from the benchmark and never use them again. There are also &lt;code class="language-text"&gt;emcee&lt;/code&gt; method that, for some unknown reasons, the fitting procedure never stops even after passing the loop limit, thus I have to remove it. Now we have 17 methods left that are stable enough to compare. Additionally, I set the max number of fitting loops as 200, so this means that any method that have equal of higher than 200 loops means that they are most likely unable to stop. I will conduct benchmarking process on the &lt;code class="language-text"&gt;CO2_measured_spectrum_4-5um.spec&lt;/code&gt; first.&lt;/p&gt;
&lt;p&gt;The result for this method-comparing benchmark can be found in &lt;a href="https://gsoc2022tranhuunhathuy.gatsbyjs.io/method_comparison.txt"&gt;this JSON file&lt;/a&gt;.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;Method&lt;/th&gt;
&lt;th align="center"&gt;Last residual&lt;/th&gt;
&lt;th align="center"&gt;Number of loops&lt;/th&gt;
&lt;th align="center"&gt;Processing time (s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;leastsq&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042272&lt;/td&gt;
&lt;td align="center"&gt;17&lt;/td&gt;
&lt;td align="center"&gt;6.128568887710571&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;least_squares&lt;/td&gt;
&lt;td align="center"&gt;0.0027299046347&lt;/td&gt;
&lt;td align="center"&gt;14&lt;/td&gt;
&lt;td align="center"&gt;3.8792104721069336&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;differential_evolution&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042330&lt;/td&gt;
&lt;td align="center"&gt;48&lt;/td&gt;
&lt;td align="center"&gt;7.211840629577637&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;brute&lt;/td&gt;
&lt;td align="center"&gt;0.0027847218345&lt;/td&gt;
&lt;td align="center"&gt;20&lt;/td&gt;
&lt;td align="center"&gt;3.13600492477417&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;basinhopping&lt;/td&gt;
&lt;td align="center"&gt;0.0030471725482&lt;/td&gt;
&lt;td align="center"&gt;201&lt;/td&gt;
&lt;td align="center"&gt;31.650216579437256&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ampgo&lt;/td&gt;
&lt;td align="center"&gt;0.0027301332094&lt;/td&gt;
&lt;td align="center"&gt;201&lt;/td&gt;
&lt;td align="center"&gt;36.60996413230896&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;nelder&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042330&lt;/td&gt;
&lt;td align="center"&gt;48&lt;/td&gt;
&lt;td align="center"&gt;7.532714605331421&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lbfgsb&lt;/td&gt;
&lt;td align="center"&gt;0.0027299043815&lt;/td&gt;
&lt;td align="center"&gt;12&lt;/td&gt;
&lt;td align="center"&gt;1.8955962657928467&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;powell&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042271&lt;/td&gt;
&lt;td align="center"&gt;38&lt;/td&gt;
&lt;td align="center"&gt;6.310025691986084&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;cg&lt;/td&gt;
&lt;td align="center"&gt;0.0027299046922&lt;/td&gt;
&lt;td align="center"&gt;34&lt;/td&gt;
&lt;td align="center"&gt;5.223567724227905&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;cobyla&lt;/td&gt;
&lt;td align="center"&gt;0.0027299044752&lt;/td&gt;
&lt;td align="center"&gt;22&lt;/td&gt;
&lt;td align="center"&gt;3.028048515319824&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;bfgs&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042351&lt;/td&gt;
&lt;td align="center"&gt;20&lt;/td&gt;
&lt;td align="center"&gt;2.9560532569885254&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;tnc&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042284&lt;/td&gt;
&lt;td align="center"&gt;36&lt;/td&gt;
&lt;td align="center"&gt;5.905533313751221&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;trust-constr&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042271&lt;/td&gt;
&lt;td align="center"&gt;16&lt;/td&gt;
&lt;td align="center"&gt;2.3700413703918457&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;slsqp&lt;/td&gt;
&lt;td align="center"&gt;0.0027299969016&lt;/td&gt;
&lt;td align="center"&gt;18&lt;/td&gt;
&lt;td align="center"&gt;3.160074472427368&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;shgo&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042272&lt;/td&gt;
&lt;td align="center"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;6.185185194015503&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;dual_annealing&lt;/td&gt;
&lt;td align="center"&gt;0.0221619241989&lt;/td&gt;
&lt;td align="center"&gt;201&lt;/td&gt;
&lt;td align="center"&gt;32.40411591529846&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;(It is important to remember that this result might differ for each run, but rest assure the common trend is unchanged)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As you can see from the data above, we have &lt;code class="language-text"&gt;basinhopping&lt;/code&gt;, &lt;code class="language-text"&gt;ampgo&lt;/code&gt; and &lt;code class="language-text"&gt;dual_annealing&lt;/code&gt; jumping out of the loop limit of 200, and it’s totally not a good thing, which I would like to exclude them out for the sake of better visualization. Then, in order to compare the rest of 14 methods, I have a scatter plot below in which I focus on analyzing the &lt;code class="language-text"&gt;last_residual&lt;/code&gt; - indicator of accuracy - on the horizontal axis, and &lt;code class="language-text"&gt;loops&lt;/code&gt; - indicator of fitting iterations needed - on the vertical axis. As &lt;code class="language-text"&gt;time&lt;/code&gt; is heavily influenced by the computational capacity of each device, I don’t prioritize it than other two criteria in the result assessment, and thus it is indicated by color code.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Scatter plot of the result." src="https://gsoc2022tranhuunhathuy.gatsbyjs.io/result_plot.png"&gt;&lt;/p&gt;
&lt;p&gt;If we zoom in the best 8 cases marked by the red rectangle above:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Best 8" src="https://gsoc2022tranhuunhathuy.gatsbyjs.io/result_zoomed.png"&gt;&lt;/p&gt;
&lt;p&gt;In the zoomed figure, the result is quite satisfying as I expected. When we talk about the most famous curve-fitting algorithms, we can mention either &lt;code class="language-text"&gt;leastsq&lt;/code&gt;/&lt;code class="language-text"&gt;least_squares&lt;/code&gt; or &lt;code class="language-text"&gt;bfgs&lt;/code&gt;/&lt;code class="language-text"&gt;lbfgsb&lt;/code&gt;, and now we can see them taking 4 out of top 5. Now let’s focus on the two competitors: &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; and &lt;code class="language-text"&gt;least_squares&lt;/code&gt; and get some observations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; has a little lower residual and so a little bit better in accuracy than &lt;code class="language-text"&gt;least_squares&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Although approximately same fitting loops (12 and 14), the time required for &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; is 1.895596s, significantly lower than &lt;code class="language-text"&gt;least_squares&lt;/code&gt; of 3.879210s. We can also see this behavior in their neighbors: &lt;code class="language-text"&gt;bfgs&lt;/code&gt; (2.956053s) &amp;lt; &lt;code class="language-text"&gt;leastsq&lt;/code&gt; (6.128569s).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is explainable. While &lt;code class="language-text"&gt;least_squares&lt;/code&gt; simply calculating and minimizing the sum of the residuals of points from the comparative curves, &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; - Limited-memory BFGS uses a limited amount of computer memory to conduct &lt;a href="https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm"&gt;Broyden-Fletcher-Goldfarb-Shanno algorithm&lt;/a&gt; for the minimization.&lt;/p&gt;
&lt;p&gt;So for now, I have initial assumption that &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; performs slightly better than &lt;code class="language-text"&gt;leastsq&lt;/code&gt;. After conducting fitting process on other spectra, the &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; and &lt;code class="language-text"&gt;leastsq&lt;/code&gt; are seem to be dominant in terms of speed (based on number of loops and time elapsed) and accuracy (this depends a little bit on pipeline combination, which will be addressed in next part) compared to other methods. However, more benchmarks are needed to confirm my initla assumption.&lt;/p&gt;
&lt;h4&gt;2. Fitting pipeline comparison&lt;/h4&gt;
&lt;p&gt;Next is the benchmarking process focusing on pipeline comparison. A fitting pipeline comprises of several options, from spectrum refinement methods such as which spectral quantity to take, whether applying normalization on both spectra or not, or simply just fitting process preferences such as maxinum number of fitting loops allowed, or fitting method, or max fitting tolerance. While in the new JSON structure the users are free to adjust all of them, through this benchmarking process I would like acquire more understandings about how these pipeline might affect the quality of a fitting work.&lt;/p&gt;
&lt;p&gt;In order to assess a fitting’s quality, I use the synthetic spectra that I generated on week 1. Although they are heavily convoluted with noises and offsets, since they are software-generated, we can know what are the experimental properties (such as &lt;code class="language-text"&gt;path_length&lt;/code&gt;, &lt;code class="language-text"&gt;slit&lt;/code&gt;, etc.). Meanwhile, regarding the experimental spectrum &lt;code class="language-text"&gt;CO2_measured_spectrum_4-5um&lt;/code&gt;, we are definitely not sure those parameters (in fact, we don’t even know whether it is LTE or non-LTE). So, I decided to test on 7 synthetic spectra:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-CO-1-1800-2300-cm-1-P3-t1500-v-r-mf0.1-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-CO2-1-500-1100-cm-1-P2-t900-v-r-mf0.5-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-CO2-1-500-3000-cm-1-P93-t740-v-r-mf0.96-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-CO2-1-3300-3700-cm-1-P0.005-t3000-v-r-mf0.01-p1-sl1.4nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-H2O-1-1000-2500-cm-1-P0.5-t1500-v-r-mf0.5-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-NH3-1-500-2000-cm-1-P10-t1000-v-r-mf0.01-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-O2-1-7500-8000-cm-1-P1.01325-t298.15-v-r-mf0.21-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For each spectra, I will modify the pipeline’s &lt;code class="language-text"&gt;method&lt;/code&gt; and &lt;code class="language-text"&gt;normalize&lt;/code&gt; properties, until the best possible fitting result is achieved - least fitting loops, and closest to the ground-truth (GT) temperature (this is why I prefer synthetic over experimental spectra, as I explained above). Here is the result:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Spec No.&lt;/th&gt;
&lt;th align="center"&gt;GT Temp&lt;/th&gt;
&lt;th align="center"&gt;Start Temp&lt;/th&gt;
&lt;th align="center"&gt;Best Temp&lt;/th&gt;
&lt;th align="center"&gt;Method&lt;/th&gt;
&lt;th align="center"&gt;Normalize&lt;/th&gt;
&lt;th align="center"&gt;Diff&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1500&lt;/td&gt;
&lt;td align="center"&gt;1300&lt;/td&gt;
&lt;td align="center"&gt;1468.97&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;lbfgsb&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/1.png"&gt;1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;2&lt;/td&gt;
&lt;td align="center"&gt;900&lt;/td&gt;
&lt;td align="center"&gt;1300&lt;/td&gt;
&lt;td align="center"&gt;898.84&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;lbfgsb&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/2.png"&gt;2&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;3&lt;/td&gt;
&lt;td align="center"&gt;740&lt;/td&gt;
&lt;td align="center"&gt;1000&lt;/td&gt;
&lt;td align="center"&gt;~740&lt;/td&gt;
&lt;td align="center"&gt;both&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/3.png"&gt;3&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;4&lt;/td&gt;
&lt;td align="center"&gt;3000&lt;/td&gt;
&lt;td align="center"&gt;2850&lt;/td&gt;
&lt;td align="center"&gt;3003.52&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/4.png"&gt;4&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;5&lt;/td&gt;
&lt;td align="center"&gt;1500&lt;/td&gt;
&lt;td align="center"&gt;2000&lt;/td&gt;
&lt;td align="center"&gt;1507.25&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;true&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/5.png"&gt;5&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;6&lt;/td&gt;
&lt;td align="center"&gt;1000&lt;/td&gt;
&lt;td align="center"&gt;2250&lt;/td&gt;
&lt;td align="center"&gt;994.90&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/6.png"&gt;6&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;7&lt;/td&gt;
&lt;td align="center"&gt;298.15&lt;/td&gt;
&lt;td align="center"&gt;660&lt;/td&gt;
&lt;td align="center"&gt;297.86&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/7.png"&gt;7&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As we can see from the table above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All spectra achieve near-perfect best fit results. This is because we have perfect ground-truth conditions. In real-life circumstances, such accurate ground-truth is virtually impossible to achieve, but this is the job of fitting users to measure and set them.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt; performs quite good in most case. This is quite surprising after the result from &lt;code class="language-text"&gt;CO2_measured_spectrum_4-5um.spec&lt;/code&gt;, but it can be explained as most likely we didn’t use the correct ground-truth conditions for it since we don’t know (seriously, who created that spectrum?). However, there is a small observation from me that, those cases where &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; lost agains &lt;code class="language-text"&gt;leastsq&lt;/code&gt; were primarily because of number of loops. Still, it’s a win for &lt;code class="language-text"&gt;leastsq&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Their neighbors, &lt;code class="language-text"&gt;least_squares&lt;/code&gt; and &lt;code class="language-text"&gt;bfgs&lt;/code&gt;, are completely underdogs. We don’t even need to mention other methods.&lt;/li&gt;
&lt;li&gt;In nearly all the best cases, &lt;code class="language-text"&gt;normalize = false&lt;/code&gt; is set. This is quite explainable, the more originality the better.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. Summary&lt;/h4&gt;
&lt;p&gt;After all the benchmarking works above, I have decided to set the &lt;code class="language-text"&gt;leastsq&lt;/code&gt; as the default fitting method, in case users don’t state the method explicitly in JSON file. Later on, in the fitting tutorial, I will add some suggestions about using &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; and trying to switch the &lt;code class="language-text"&gt;normalize&lt;/code&gt; in case their fitting work is not quite good.&lt;/p&gt;
&lt;p&gt;Nevertheless, these benchmarks helped me gain more insights about the performance of my fitting module, and most importantly, let me experience the feeling of a spectroscopist trying to fit his spectra - playing around the parameters, adjusting parameters and praying for a good result to come. Quite a physically and mentally exhausting work to be honest, since whenever the result went wrong, I didn’t know whether the error came from ground-truth conditions, or from my fitting module. There have been days and nights I sat in front of my laptop adjusting the JSON files and codebase continuously. But finally, the benchmarking process for LTE spectra is good now, and I am quite confident in my fitting module. Now let’s move on to the non-LTE spectra!&lt;/p&gt;
&lt;p&gt;&lt;img alt="A footage of me turning parameters up and down like a DJ" src="https://gsoc2022tranhuunhathuy.gatsbyjs.io/meme.jpg"&gt;&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/07/20220717_0000_tranhuunhathuy/</guid><pubDate>Sat, 16 Jul 2022 23:00:00 GMT</pubDate></item><item><title>Benchmarking and performance analysis</title><link>http://openastronomy.org/Universe_OA/posts/2022/07/20220710_0000_arunavabasu-03/</link><dc:creator>arunavabasu-03</dc:creator><description>&lt;p&gt;Radis app uses  useState  to populate data and maintain state; while this works well for small scale applications, as it becomes better over…&lt;/p&gt;
&lt;div style="margin-top: 50px; font-style: italic;"&gt;&lt;strong&gt;&lt;a href="https://minimal-blog.lekoarts.de/3rdWeek"&gt;Keep reading&lt;/a&gt;.&lt;/strong&gt;&lt;/div&gt;&lt;br&gt; &lt;br&gt;
&lt;!-- TEASER_END --&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/07/20220710_0000_arunavabasu-03/</guid><pubDate>Sat, 09 Jul 2022 23:00:00 GMT</pubDate></item><item><title>Fourth week - Intensive benchmarking process for LTE spectra</title><link>http://openastronomy.org/Universe_OA/posts/2022/07/20220710_0000_tranhuunhathuy/</link><dc:creator>TranHuuNhatHuy</dc:creator><description>&lt;p&gt;As my fitting module has completed, now I am clear to start the benchmarking process. Initially, I planned to do it on 4 categories: large, small, LTE and non-LTE. But then, Mr. Erwan’s words helped me realize that my classification was somehow not ideal for this, as he said:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The first need is not fitting performance, its a good fitting interface they would work on every typical condition.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;Do not wasting time trying to determine a perfect threshold or categories.&lt;/p&gt;
&lt;p&gt;Work on real-life examples. CO2 4.2 - 5 µm is one.&lt;/p&gt;
&lt;p&gt;CO2 bandhead (the Single Temperature fit example) is another one.&lt;/p&gt;
&lt;p&gt;Works on the improving the fits from these real-life examples,
and - maybe - you’ll generalize to categories/classifications eventually.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To be honest, I have been thinking about changing my project timeline and objectives a little bit. Initially, I proposed the timeline in which I would spend 1 week for making the module, and 4 weeks to conduct benchmarking on 4 types of spectrum (large, small, LTE, non-LTE). But then, I encountered a lot of difficulties in conducting the fitting process, which significantly delays my fitting module to be completed in the end of week 3. Along with Mr. Erwan’s suggestions, after careful considerations, I have decided to reduce the category to only 2 groups of LTE and non-LTE spectra, and propose a new timeline based on that with my mentors, which successfully acquired their approvals. The new timeline is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Week 4 (this week): conduct benchmarking process on LTE spectra.&lt;/li&gt;
&lt;li&gt;Week 5: conduct benchmarking process on non-LTE spectra.&lt;/li&gt;
&lt;li&gt;Week 6: implement the fitting module and fitting models into RADIS codebase, finish any documentations, create a 101 tutorial, and prepare for first evaluation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For this new timeline, the last week is going to be the toughest time ever! But I will try my best to catch up with the deadlines once and for all. I must admit that after half the first phase, I realized that my expected timeline in my project proposal - derived from my initial understandings of RADIS and fitting - is quite not applicable. As Mr. Minou - one of my mentors, said:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don’t worry about changing the objectives . Some difficulties usually come up only when the project begins and cannot
be easily anticipated. New directions seem fine to me and you are on the right path.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As well as Mr. Erwan:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Just keep on progressing on the project as you do, reevaluating needs if needed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I have more confidence in keeping on with my plan. This new approach, hopefully, will allow me to finish implementing the fitting module into RADIS by the end of first phase. Quite an intensive experience for me but, let’s go anyway! So here are the benchmarking results for our LTE experimental spectra, in which I will focus on comparison between fitting methods, and between refinement pipelines.&lt;/p&gt;
&lt;h4&gt;1. Fitting method benchmarking&lt;/h4&gt;
&lt;p&gt;The ideal of benchmarking result is to test and assess under what conditions, such as fitting method, pipeline, refinement, etc., the fitting process can achieve a stable and robust result. Firstly, I want to test the fitting method and see which ones are the best to put into the module as the default method. As we use LMFIT.Minimizer, we have 23 fitting methods in total:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt;: Levenberg-Marquardt (default).&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;least_squares&lt;/code&gt;: Least-Squares minimization, using Trust Region Reflective method.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;differential_evolution&lt;/code&gt;: differential evolution.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;brute&lt;/code&gt;: brute force method.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;basinhopping&lt;/code&gt;: Basin-hopping method.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;ampgo&lt;/code&gt;: Adaptive Memory Programming for Global Optimization.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;nelder&lt;/code&gt;: Nelder-Mead.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;lbfgsb&lt;/code&gt;: Limited-memory Broyden–Fletcher–Goldfarb–Shanno (L-BFGS-B).&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;powell&lt;/code&gt;: Powell’s method.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;cg&lt;/code&gt;: Conjugate-Gradient.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;newton&lt;/code&gt;: Newton-Conjugate-Gradient.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;cobyla&lt;/code&gt;: Cobyla.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;bfgs&lt;/code&gt;: Broyden–Fletcher–Goldfarb–Shanno (BFGS).&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;tnc&lt;/code&gt;: Truncated Newton.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;trust-ncg&lt;/code&gt;: Newton-Conjugate-Gradient trust-region.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;trust-exact&lt;/code&gt;: nearly exact trust-region.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;trust-krylov&lt;/code&gt;: Newton’s Generalized Lanczos Trust-Region (GLTR).&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;trust-constr&lt;/code&gt;: trust-region for constrained optimization.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;dogleg&lt;/code&gt;: Dog-leg trust-region.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;slsqp&lt;/code&gt;: Sequential Linear Squares Programming.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;emcee&lt;/code&gt;: Maximum likelihood via Monte-Carlo Markov Chain.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;shgo&lt;/code&gt;: Simplicial Homology Global Optimization.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;dual_annealing&lt;/code&gt;: Dual Annealing optimization.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this list, there are 5 methods - &lt;code class="language-text"&gt;newton&lt;/code&gt;, &lt;code class="language-text"&gt;trust-ncg&lt;/code&gt;, &lt;code class="language-text"&gt;trust_exact&lt;/code&gt;, &lt;code class="language-text"&gt;trust-krylov&lt;/code&gt; and &lt;code class="language-text"&gt;dogleg&lt;/code&gt; - that require Jacobian function to work, which adds more complexity into our fitting process and codebase, hence I remove them from the benchmark and never use them again. There are also &lt;code class="language-text"&gt;emcee&lt;/code&gt; method that, for some unknown reasons, the fitting procedure never stops even after passing the loop limit, thus I have to remove it. Now we have 17 methods left that are stable enough to compare. Additionally, I set the max number of fitting loops as 200, so this means that any method that have equal of higher than 200 loops means that they are most likely unable to stop. I will conduct benchmarking process on the &lt;code class="language-text"&gt;CO2_measured_spectrum_4-5um.spec&lt;/code&gt; first.&lt;/p&gt;
&lt;p&gt;The result for this method-comparing benchmark can be found in &lt;a href="https://gsoc2022tranhuunhathuy.gatsbyjs.io/43e71f48257a8a3d444d530c8859e77b/method_comparison.txt"&gt;this JSON file&lt;/a&gt;.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;Method&lt;/th&gt;
&lt;th align="center"&gt;Last residual&lt;/th&gt;
&lt;th align="center"&gt;Number of loops&lt;/th&gt;
&lt;th align="center"&gt;Processing time (s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;leastsq&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042272&lt;/td&gt;
&lt;td align="center"&gt;17&lt;/td&gt;
&lt;td align="center"&gt;6.128568887710571&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;least_squares&lt;/td&gt;
&lt;td align="center"&gt;0.0027299046347&lt;/td&gt;
&lt;td align="center"&gt;14&lt;/td&gt;
&lt;td align="center"&gt;3.8792104721069336&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;differential_evolution&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042330&lt;/td&gt;
&lt;td align="center"&gt;48&lt;/td&gt;
&lt;td align="center"&gt;7.211840629577637&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;brute&lt;/td&gt;
&lt;td align="center"&gt;0.0027847218345&lt;/td&gt;
&lt;td align="center"&gt;20&lt;/td&gt;
&lt;td align="center"&gt;3.13600492477417&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;basinhopping&lt;/td&gt;
&lt;td align="center"&gt;0.0030471725482&lt;/td&gt;
&lt;td align="center"&gt;201&lt;/td&gt;
&lt;td align="center"&gt;31.650216579437256&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ampgo&lt;/td&gt;
&lt;td align="center"&gt;0.0027301332094&lt;/td&gt;
&lt;td align="center"&gt;201&lt;/td&gt;
&lt;td align="center"&gt;36.60996413230896&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;nelder&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042330&lt;/td&gt;
&lt;td align="center"&gt;48&lt;/td&gt;
&lt;td align="center"&gt;7.532714605331421&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lbfgsb&lt;/td&gt;
&lt;td align="center"&gt;0.0027299043815&lt;/td&gt;
&lt;td align="center"&gt;12&lt;/td&gt;
&lt;td align="center"&gt;1.8955962657928467&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;powell&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042271&lt;/td&gt;
&lt;td align="center"&gt;38&lt;/td&gt;
&lt;td align="center"&gt;6.310025691986084&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;cg&lt;/td&gt;
&lt;td align="center"&gt;0.0027299046922&lt;/td&gt;
&lt;td align="center"&gt;34&lt;/td&gt;
&lt;td align="center"&gt;5.223567724227905&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;cobyla&lt;/td&gt;
&lt;td align="center"&gt;0.0027299044752&lt;/td&gt;
&lt;td align="center"&gt;22&lt;/td&gt;
&lt;td align="center"&gt;3.028048515319824&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;bfgs&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042351&lt;/td&gt;
&lt;td align="center"&gt;20&lt;/td&gt;
&lt;td align="center"&gt;2.9560532569885254&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;tnc&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042284&lt;/td&gt;
&lt;td align="center"&gt;36&lt;/td&gt;
&lt;td align="center"&gt;5.905533313751221&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;trust-constr&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042271&lt;/td&gt;
&lt;td align="center"&gt;16&lt;/td&gt;
&lt;td align="center"&gt;2.3700413703918457&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;slsqp&lt;/td&gt;
&lt;td align="center"&gt;0.0027299969016&lt;/td&gt;
&lt;td align="center"&gt;18&lt;/td&gt;
&lt;td align="center"&gt;3.160074472427368&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;shgo&lt;/td&gt;
&lt;td align="center"&gt;0.0027299042272&lt;/td&gt;
&lt;td align="center"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;6.185185194015503&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;dual_annealing&lt;/td&gt;
&lt;td align="center"&gt;0.0221619241989&lt;/td&gt;
&lt;td align="center"&gt;201&lt;/td&gt;
&lt;td align="center"&gt;32.40411591529846&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;(It is important to remember that this result might differ for each run, but rest assure the common trend is unchanged)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As you can see from the data above, we have &lt;code class="language-text"&gt;basinhopping&lt;/code&gt;, &lt;code class="language-text"&gt;ampgo&lt;/code&gt; and &lt;code class="language-text"&gt;dual_annealing&lt;/code&gt; jumping out of the loop limit of 200, and it’s totally not a good thing, which I would like to exclude them out for the sake of better visualization. Then, in order to compare the rest of 14 methods, I have a scatter plot below in which I focus on analyzing the &lt;code class="language-text"&gt;last_residual&lt;/code&gt; - indicator of accuracy - on the horizontal axis, and &lt;code class="language-text"&gt;loops&lt;/code&gt; - indicator of fitting iterations needed - on the vertical axis. As &lt;code class="language-text"&gt;time&lt;/code&gt; is heavily influenced by the computational capacity of each device, I don’t prioritize it than other two criteria in the result assessment, and thus it is indicated by color code.&lt;/p&gt;
&lt;p&gt;&lt;span class="gatsby-resp-image-wrapper" style="display: block; margin-left: auto; margin-right: auto;"&gt;
&lt;a class="gatsby-resp-image-link" href="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/41c56cdd9aa439841d66bb9a01dd543d/29114/result_plot.png" rel="noopener" style="display: block;" target="_blank"&gt;
&lt;span class="gatsby-resp-image-background-image" style="display: block;"&gt;&lt;/span&gt;
&lt;img alt="Scatter plot of the result." class="gatsby-resp-image-image" src="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/41c56cdd9aa439841d66bb9a01dd543d/f058b/result_plot.png" style="width: 100%; height: 100%; margin: 0; vertical-align: middle;" title="Scatter plot of the result."&gt;
&lt;/a&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;If we zoom in the best 8 cases marked by the red rectangle above:&lt;/p&gt;
&lt;p&gt;&lt;span class="gatsby-resp-image-wrapper" style="display: block; margin-left: auto; margin-right: auto;"&gt;
&lt;a class="gatsby-resp-image-link" href="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/b03e6b2a34c2ea21d9bc963c5d6e7acf/29114/result_zoomed.png" rel="noopener" style="display: block;" target="_blank"&gt;
&lt;span class="gatsby-resp-image-background-image" style="display: block;"&gt;&lt;/span&gt;
&lt;img alt="Best 8" class="gatsby-resp-image-image" src="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/b03e6b2a34c2ea21d9bc963c5d6e7acf/f058b/result_zoomed.png" style="width: 100%; height: 100%; margin: 0; vertical-align: middle;" title="Best 8"&gt;
&lt;/a&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In the zoomed figure, the result is quite satisfying as I expected. When we talk about the most famous curve-fitting algorithms, we can mention either &lt;code class="language-text"&gt;leastsq&lt;/code&gt;/&lt;code class="language-text"&gt;least_squares&lt;/code&gt; or &lt;code class="language-text"&gt;bfgs&lt;/code&gt;/&lt;code class="language-text"&gt;lbfgsb&lt;/code&gt;, and now we can see them taking 4 out of top 5. Now let’s focus on the two competitors: &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; and &lt;code class="language-text"&gt;least_squares&lt;/code&gt; and get some observations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; has a little lower residual and so a little bit better in accuracy than &lt;code class="language-text"&gt;least_squares&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Although approximately same fitting loops (12 and 14), the time required for &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; is 1.895596s, significantly lower than &lt;code class="language-text"&gt;least_squares&lt;/code&gt; of 3.879210s. We can also see this behavior in their neighbors: &lt;code class="language-text"&gt;bfgs&lt;/code&gt; (2.956053s) &amp;lt; &lt;code class="language-text"&gt;leastsq&lt;/code&gt; (6.128569s).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is explainable. While &lt;code class="language-text"&gt;least_squares&lt;/code&gt; simply calculating and minimizing the sum of the residuals of points from the comparative curves, &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; - Limited-memory BFGS uses a limited amount of computer memory to conduct &lt;a href="https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm"&gt;Broyden-Fletcher-Goldfarb-Shanno algorithm&lt;/a&gt; for the minimization.&lt;/p&gt;
&lt;p&gt;So for now, I have initial assumption that &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; performs slightly better than &lt;code class="language-text"&gt;leastsq&lt;/code&gt;. After conducting fitting process on other spectra, the &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; and &lt;code class="language-text"&gt;leastsq&lt;/code&gt; are seem to be dominant in terms of speed (based on number of loops and time elapsed) and accuracy (this depends a little bit on pipeline combination, which will be addressed in next part) compared to other methods. However, more benchmarks are needed to confirm my initla assumption.&lt;/p&gt;
&lt;h4&gt;2. Fitting pipeline comparison&lt;/h4&gt;
&lt;p&gt;Next is the benchmarking process focusing on pipeline comparison. A fitting pipeline comprises of several options, from spectrum refinement methods such as which spectral quantity to take, whether applying normalization on both spectra or not, or simply just fitting process preferences such as maxinum number of fitting loops allowed, or fitting method, or max fitting tolerance. While in the new JSON structure the users are free to adjust all of them, through this benchmarking process I would like acquire more understandings about how these pipeline might affect the quality of a fitting work.&lt;/p&gt;
&lt;p&gt;In order to assess a fitting’s quality, I use the synthetic spectra that I generated on week 1. Although they are heavily convoluted with noises and offsets, since they are software-generated, we can know what are the experimental properties (such as &lt;code class="language-text"&gt;path_length&lt;/code&gt;, &lt;code class="language-text"&gt;slit&lt;/code&gt;, etc.). Meanwhile, regarding the experimental spectrum &lt;code class="language-text"&gt;CO2_measured_spectrum_4-5um&lt;/code&gt;, we are definitely not sure those parameters (in fact, we don’t even know whether it is LTE or non-LTE). So, I decided to test on 7 synthetic spectra:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-CO-1-1800-2300-cm-1-P3-t1500-v-r-mf0.1-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-CO2-1-500-1100-cm-1-P2-t900-v-r-mf0.5-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-CO2-1-500-3000-cm-1-P93-t740-v-r-mf0.96-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-CO2-1-3300-3700-cm-1-P0.005-t3000-v-r-mf0.01-p1-sl1.4nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-H2O-1-1000-2500-cm-1-P0.5-t1500-v-r-mf0.5-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-NH3-1-500-2000-cm-1-P10-t1000-v-r-mf0.01-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;synth-O2-1-7500-8000-cm-1-P1.01325-t298.15-v-r-mf0.21-p1-sl1nm.spec&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For each spectra, I will modify the pipeline’s &lt;code class="language-text"&gt;method&lt;/code&gt; and &lt;code class="language-text"&gt;normalize&lt;/code&gt; properties, until the best possible fitting result is achieved - least fitting loops, and closest to the ground-truth (GT) temperature (this is why I prefer synthetic over experimental spectra, as I explained above). Here is the result:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;Spec No.&lt;/th&gt;
&lt;th align="center"&gt;GT Temp&lt;/th&gt;
&lt;th align="center"&gt;Start Temp&lt;/th&gt;
&lt;th align="center"&gt;Best Temp&lt;/th&gt;
&lt;th align="center"&gt;Method&lt;/th&gt;
&lt;th align="center"&gt;Normalize&lt;/th&gt;
&lt;th align="center"&gt;Diff&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;1500&lt;/td&gt;
&lt;td align="center"&gt;1300&lt;/td&gt;
&lt;td align="center"&gt;1468.97&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;lbfgsb&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/1.png"&gt;1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;2&lt;/td&gt;
&lt;td align="center"&gt;900&lt;/td&gt;
&lt;td align="center"&gt;1300&lt;/td&gt;
&lt;td align="center"&gt;898.84&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;lbfgsb&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/2.png"&gt;2&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;3&lt;/td&gt;
&lt;td align="center"&gt;740&lt;/td&gt;
&lt;td align="center"&gt;1000&lt;/td&gt;
&lt;td align="center"&gt;~740&lt;/td&gt;
&lt;td align="center"&gt;both&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/3.png"&gt;3&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;4&lt;/td&gt;
&lt;td align="center"&gt;3000&lt;/td&gt;
&lt;td align="center"&gt;2850&lt;/td&gt;
&lt;td align="center"&gt;3003.52&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/4.png"&gt;4&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;5&lt;/td&gt;
&lt;td align="center"&gt;1500&lt;/td&gt;
&lt;td align="center"&gt;2000&lt;/td&gt;
&lt;td align="center"&gt;1507.25&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;true&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/5.png"&gt;5&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;6&lt;/td&gt;
&lt;td align="center"&gt;1000&lt;/td&gt;
&lt;td align="center"&gt;2250&lt;/td&gt;
&lt;td align="center"&gt;994.90&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/6.png"&gt;6&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;7&lt;/td&gt;
&lt;td align="center"&gt;298.15&lt;/td&gt;
&lt;td align="center"&gt;660&lt;/td&gt;
&lt;td align="center"&gt;297.86&lt;/td&gt;
&lt;td align="center"&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;false&lt;/td&gt;
&lt;td align="center"&gt;&lt;a href="https://raw.githubusercontent.com/TranHuuNhatHuy/my-2022-gsoc-journey/master/content/blog/5.%204th-week/7.png"&gt;7&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As we can see from the table above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All spectra achieve near-perfect best fit results. This is because we have perfect ground-truth conditions. In real-life circumstances, such accurate ground-truth is virtually impossible to achieve, but this is the job of fitting users to measure and set them.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;leastsq&lt;/code&gt; performs quite good in most case. This is quite surprising after the result from &lt;code class="language-text"&gt;CO2_measured_spectrum_4-5um.spec&lt;/code&gt;, but it can be explained as most likely we didn’t use the correct ground-truth conditions for it since we don’t know (seriously, who created that spectrum?). However, there is a small observation from me that, those cases where &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; lost agains &lt;code class="language-text"&gt;leastsq&lt;/code&gt; were primarily because of number of loops. Still, it’s a win for &lt;code class="language-text"&gt;leastsq&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Their neighbors, &lt;code class="language-text"&gt;least_squares&lt;/code&gt; and &lt;code class="language-text"&gt;bfgs&lt;/code&gt;, are completely underdogs. We don’t even need to mention other methods.&lt;/li&gt;
&lt;li&gt;In nearly all the best cases, &lt;code class="language-text"&gt;normalize = false&lt;/code&gt; is set. This is quite explainable, the more originality the better.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. Summary&lt;/h4&gt;
&lt;p&gt;After all the benchmarking works above, I have decided to set the &lt;code class="language-text"&gt;leastsq&lt;/code&gt; as the default fitting method, in case users don’t state the method explicitly in JSON file. Later on, in the fitting tutorial, I will add some suggestions about using &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; and trying to switch the &lt;code class="language-text"&gt;normalize&lt;/code&gt; in case their fitting work is not quite good.&lt;/p&gt;
&lt;p&gt;Nevertheless, these benchmarks helped me gain more insights about the performance of my fitting module, and most importantly, let me experience the feeling of a spectroscopist trying to fit his spectra - playing around the parameters, adjusting parameters and praying for a good result to come. Quite a physically and mentally exhausting work to be honest, since whenever the result went wrong, I didn’t know whether the error came from ground-truth conditions, or from my fitting module. There have been days and nights I sat in front of my laptop adjusting the JSON files and codebase continuously. But finally, the benchmarking process for LTE spectra is good now, and I am quite confident in my fitting module. Now let’s move on to the non-LTE spectra!&lt;/p&gt;
&lt;p&gt;&lt;span class="gatsby-resp-image-wrapper" style="display: block; margin-left: auto; margin-right: auto;"&gt;
&lt;a class="gatsby-resp-image-link" href="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/83691995f7e77035e5034ccbfb1a61ff/41099/meme.jpg" rel="noopener" style="display: block;" target="_blank"&gt;
&lt;span class="gatsby-resp-image-background-image" style="display: block;"&gt;&lt;/span&gt;
&lt;img alt="A footage of me turning parameters up and down like a DJ" class="gatsby-resp-image-image" src="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/83691995f7e77035e5034ccbfb1a61ff/41099/meme.jpg" style="width: 100%; height: 100%; margin: 0; vertical-align: middle;" title="A footage of me turning parameters up and down like a DJ"&gt;
&lt;/a&gt;
&lt;/span&gt;&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/07/20220710_0000_tranhuunhathuy/</guid><pubDate>Sat, 09 Jul 2022 23:00:00 GMT</pubDate></item><item><title>Week 3 and Week 4</title><link>http://openastronomy.org/Universe_OA/posts/2022/07/20220709_0000_supriya1702/</link><dc:creator>Supriya1702</dc:creator><description>&lt;p&gt;So, after looking into the hapi.py  and its functionalities I got to know that after passing extra parameters like 'gamma_CO2', 'n_CO2' for…&lt;/p&gt;
&lt;div style="margin-top: 50px; font-style: italic;"&gt;&lt;strong&gt;&lt;a href="https://minimal-blog.lekoarts.de/week-3-and-week-4"&gt;Keep reading&lt;/a&gt;.&lt;/strong&gt;&lt;/div&gt;&lt;br&gt; &lt;br&gt;
&lt;!-- TEASER_END --&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/07/20220709_0000_supriya1702/</guid><pubDate>Fri, 08 Jul 2022 23:00:00 GMT</pubDate></item><item><title>Third week - Finalizing fitting module after long days of struggling</title><link>http://openastronomy.org/Universe_OA/posts/2022/07/20220703_0000_tranhuunhathuy/</link><dc:creator>TranHuuNhatHuy</dc:creator><description>&lt;p&gt;To be honest, I started this week realizing I was far behind the deadline. After suffering a traumatizing fever which incapacitated me for one week, I had a fitting module which did not run correctly. Starting this week, the JSON parsing worked normally, but for some reasons the fitting process kept plummeting the &lt;code class="language-text"&gt;Tgas&lt;/code&gt; value either to very high or very low guesses, always out of the boundaries. What are they trying to seek? I don’t know. So, I have spent this third week trying my best to fix the fitting module and make it run normally:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;At first, I suspected this was a fault in the return of cost function, so I tried either &lt;a href="https://radis.readthedocs.io/en/latest/source/radis.spectrum.compare.html#radis.spectrum.compare.get_diff"&gt;get_diff()&lt;/a&gt; or &lt;a href="https://radis.readthedocs.io/en/latest/source/radis.spectrum.compare.html#radis.spectrum.compare.get_residual"&gt;get_residual()&lt;/a&gt;. The fitting process varied between the two approaches, but in the end the plummeting value prevailed.&lt;/li&gt;
&lt;!-- TEASER_END --&gt;
&lt;li&gt;Then, I thought my synthetic spectra were faulty, so I decided to regenerate and restructure them all over again, and the problem was still there.&lt;/li&gt;
&lt;li&gt;At this time I was still believing that the problem came from the difference between two spectra. So I tried my best to put the generation of two spectra as similar as possible, but still no progress.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It was around this point that I received some mind-blowing feedbacks from Mr. Erwan Pannier - one of my mentors:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do not wasting time trying to determine a perfect threshold or categories.&lt;/p&gt;
&lt;p&gt;Work on real-life examples. CO2 4.2 - 5 µm is one.&lt;/p&gt;
&lt;p&gt;CO2 bandhead (the Single Temperature fit example) is another one.&lt;/p&gt;
&lt;p&gt;Works on the improving the fits from these real-life examples,
and - maybe - you’ll generalize to categories/classifications eventually.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;At some point, I tried to use &lt;a href="https://radis.readthedocs.io/en/latest/source/radis.spectrum.spectrum.html#radis.spectrum.spectrum.Spectrum.normalize"&gt;normalize()&lt;/a&gt;. My idea is, since my current fitting target is temperature, the experimental and model spectra can be both normalized, as the spectrum lineshape is determined by the component temperatures. After normalizing, things worked perfectly out of my expectation!&lt;/p&gt;
&lt;p&gt;And so, after one week of pure suffering and perseverance, I have finished the fitting module! So, there are 3 important parts of my fitting feature:&lt;/p&gt;
&lt;h4&gt;1. Input JSON file&lt;/h4&gt;
&lt;p&gt;A JSON file containing every information, from path to experimental spectrum file, to initial conditions - known parameters that will be used for calculating model spectra, and fit parameter(s) are also stated here. For example:&lt;/p&gt;
&lt;div class="gatsby-highlight"&gt;&lt;pre class="language-json"&gt;&lt;code class="language-json"&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
&lt;span class="token property"&gt;"fileName"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token string"&gt;"CO2_measured_spectrum_4-5um.spec"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;
&lt;span class="token property"&gt;"molecule"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token string"&gt;"CO2"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;
&lt;span class="token property"&gt;"isotope"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token string"&gt;"1,2"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;
&lt;span class="token property"&gt;"wmin"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token number"&gt;4167&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;
&lt;span class="token property"&gt;"wmax"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token number"&gt;4180&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;
&lt;span class="token property"&gt;"wunit"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token string"&gt;"nm"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;
&lt;span class="token property"&gt;"pressure"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token number"&gt;1e-3&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;
&lt;span class="token property"&gt;"mole_fraction"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token number"&gt;1&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;
&lt;span class="token property"&gt;"path_length"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;
&lt;span class="token property"&gt;"slit"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token string"&gt;"1.4 nm"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;
&lt;span class="token property"&gt;"fit"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
&lt;span class="token property"&gt;"Tgas"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token number"&gt;1100&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;
&lt;span class="token property"&gt;"bound_Tgas"&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt; &lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;300&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token number"&gt;2000&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see from the JSON file above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class="language-text"&gt;fileName&lt;/code&gt; : path to the &lt;code class="language-text"&gt;.spec&lt;/code&gt; spectrum file from &lt;code class="language-text"&gt;./data/&lt;/code&gt;, will be changed when implementing to RADIS codebase. For now the format is &lt;code class="language-text"&gt;&amp;lt;spectrum-type&amp;gt;/spectrum/&amp;lt;name&amp;gt;.spec&lt;/code&gt;. For example: &lt;code class="language-text"&gt;large/spectrum/CO2_measured_spectrum_4-5um.spec&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Parameters from &lt;code class="language-text"&gt;molecule&lt;/code&gt; to &lt;code class="language-text"&gt;slit&lt;/code&gt; are used for calculating model spectrum later. &lt;code class="language-text"&gt;wmin&lt;/code&gt; and &lt;code class="language-text"&gt;wmax&lt;/code&gt; are used to determine the range of wavelength/wavenumber that will be cropped from original experimental spectrum.&lt;/li&gt;
&lt;li&gt;&lt;code class="language-text"&gt;fit&lt;/code&gt; section contains fit parameters and their corresponding initial values or fitting bounds. In the example above, fit parameter &lt;code class="language-text"&gt;Tgas&lt;/code&gt; has initial value of 1100 and fitting bound [300, 2000].&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. Fitting module &lt;code class="language-text"&gt;fitting_module.py&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Contains functions to load JSON file &lt;code class="language-text"&gt;get_JSON()&lt;/code&gt; and most importantly, &lt;code class="language-text"&gt;fit_spectrum()&lt;/code&gt; which receives only path of JSON file as input parameter, and will do all the fitting work for you.&lt;/p&gt;
&lt;p&gt;Firstly, when being called, &lt;code class="language-text"&gt;fit_spectrum()&lt;/code&gt; will call and parse the input path to &lt;code class="language-text"&gt;get_JSON()&lt;/code&gt; which reads necessary information from the JSON file. These information are returned to &lt;code class="language-text"&gt;fit_spectrum()&lt;/code&gt;, which will try to retrieve experimental data. Then, it crops, normalizes, removes NaN values, and some other refinements. Next, the read information and refined experimental spectrum will be sent to fitting models for the fitting process, which is described below.&lt;/p&gt;
&lt;h4&gt;3. Fitting models &lt;code class="language-text"&gt;model_LTE.py&lt;/code&gt; and &lt;code class="language-text"&gt;model_nonLTE.py&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;These 2 files contain &lt;code class="language-text"&gt;residual_LTE()&lt;/code&gt; - for LTE spectra, and &lt;code class="language-text"&gt;residual_NonLTE()&lt;/code&gt; - for non-LTE spectra (I haven’t developed this yet, will be done this week according to timeline), respectively. These functions receives refined experimental spectrum and initial conditions read from JSON file before, then calculate model spectrum, refine it, and return the residual/difference/cost between 2 spectra.&lt;/p&gt;
&lt;h4&gt;4. Initial result when fitting &lt;code class="language-text"&gt;CO2_measured_spectrum_4-5um.spec&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;I tried to recreate the same fitting scenario as &lt;a href="https://radis.readthedocs.io/en/latest/auto_examples/plot_1T_fit.html#sphx-glr-auto-examples-plot-1t-fit-py"&gt;1-temp fit example&lt;/a&gt;. The result of my module seems promising, with only 17 iterations compared to 32 iterations in the example.&lt;/p&gt;
&lt;div class="gatsby-highlight"&gt;&lt;pre class="language-text"&gt;&lt;code class="language-text"&gt;Succesfully finished the fitting process in 7.901483058929443s.
[[Fit Statistics]]
# fitting method   = leastsq
# function evals   = 17
# data points      = 1
# variables        = 1
chi-square         = 7.4524e-06
reduced chi-square = 7.4524e-06
Akaike info crit   = -9.80697750
Bayesian info crit = -11.8069775
[[Variables]]
Tgas:  1459.11902 +/- 26872889.5 (1841720.19%) (init = 1100)
e:\radis\radis\misc\warning.py:354: HighTemperatureWarning: HITRAN is valid for low temperatures (typically &amp;lt; 700 K). For higher temperatures you may need HITEMP or CDSD. See the 'databank=' parameter
warnings.warn(WarningType(message))
e:\radis\radis\misc\curve.py:241: UserWarning: Presence of NaN in curve_divide!
Think about interpolation=2
warnings.warn(&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="gatsby-resp-image-wrapper" style="display: block; margin-left: auto; margin-right: auto;"&gt;
&lt;a class="gatsby-resp-image-link" href="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/c1ca7b795588d0c7ddc1076fc8fce6b8/9e818/fitting_result.png" rel="noopener" style="display: block;" target="_blank"&gt;
&lt;span class="gatsby-resp-image-background-image" style="display: block;"&gt;&lt;/span&gt;
&lt;img alt="Comparison between normalized experimental spectrum and best fitted spectrum" class="gatsby-resp-image-image" src="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/c1ca7b795588d0c7ddc1076fc8fce6b8/f058b/fitting_result.png" style="width: 100%; height: 100%; margin: 0; vertical-align: middle;" title="Comparison between normalized experimental spectrum and best fitted spectrum"&gt;
&lt;/a&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;5. RADIS fitting process from user perspective in the future&lt;/h4&gt;
&lt;p&gt;If being implemented, this fitting pipeline will benefit RADIS users, especially new users, in the future. Imagine you have a spectrum to be fitted. All you need to do next, is to fill the information into a JSON form, and then call &lt;code class="language-text"&gt;fit_spectrum(&amp;lt;path-to-JSON-file&amp;gt;)&lt;/code&gt; and let it do all the work. If you are not satisfied with the result, you can change the unknown information in the JSON, such as &lt;code class="language-text"&gt;slit&lt;/code&gt; and &lt;code class="language-text"&gt;path_length&lt;/code&gt;, and recall the function again, until you are satisfied.&lt;/p&gt;
&lt;p&gt;This is way easier and much friendlier for RADIS users than dwelling into RADIS documentation to find out and learn how to use existing fitting pipeline.&lt;/p&gt;
&lt;p&gt;For now, this user interface only allows LTE spectra to be fitted. But in the following weeks, more types will be implemented and covered along with results from benchmarking progress.&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/07/20220703_0000_tranhuunhathuy/</guid><pubDate>Sat, 02 Jul 2022 23:00:00 GMT</pubDate></item><item><title>Linting and MUI^5 support</title><link>http://openastronomy.org/Universe_OA/posts/2022/06/20220626_0000_arunavabasu-03/</link><dc:creator>arunavabasu-03</dc:creator><description>&lt;p&gt;React 18 Migration Because Radis is currently using an outdated version of React, we have chosen to upgrade to React 18. Linting and type…&lt;/p&gt;
&lt;div style="margin-top: 50px; font-style: italic;"&gt;&lt;strong&gt;&lt;a href="https://minimal-blog.lekoarts.de/1stAnd2ndWeek"&gt;Keep reading&lt;/a&gt;.&lt;/strong&gt;&lt;/div&gt;&lt;br&gt; &lt;br&gt;
&lt;!-- TEASER_END --&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/06/20220626_0000_arunavabasu-03/</guid><pubDate>Sat, 25 Jun 2022 23:00:00 GMT</pubDate></item></channel></rss>